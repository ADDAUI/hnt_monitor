get_cursor() {
  p=${1:-"${payload}"}
  cursor=$(jq -r 'select(.cursor != null) | .cursor' <<< "${p}" 2>/dev/null) || log_info "cursor data empty"
}

get_payload() {
  get_curl_options
  payload=$(curl ${curl_options} "${url}" || jq '.' 2>/dev/null) || log_err "api timeout"
}

next_payload() {
  get_curl_options
  new_payload=$(curl ${curl_options} "${url}&cursor=${cursor}" | jq '.' 2>/dev/null) || log_err "api timeout"
}

send_payload() {
  if [ "${id}" == "collector.bobcat.miner" ]; then
    payload=$(jq 'del(.temp0, .temp1, .onboarding)' <<< "${payload}") || log_err "Could not convert bobcat payload"
  elif [ "${id}" == "collector.longap.status" ]; then
    payload=$(jq '.[]' <<< "${payload}" 2>/dev/null) || log_err "Could not convert longap payload"
  fi

  if [[ "${collector_storage_profile}" == *"local"* ]] || [ ! "${collector_storage_profile}" ]; then
    option=${1:-""}
    directory=${2:-""}

    if [ "${directory}" ]; then
      if [ "${option}" == "write" ]; then
        echo "${payload}" > "${directory}"
      elif [ "${option}" == "append" ]; then
        echo "${payload}" >> "${directory}"
      else
        log_err "invalid option - ${option}"
      fi
    else
      log_err "no directory to send payload was specified"
    fi
  fi

  if [[ "${collector_storage_profile}" == *"elasticsearch"* ]] && [ "${elasticsearch_url}" ]; then
    get_curl_options
    option=${1:-""}
    a=${a:-"${endpoint}"}
    client_id=${client_id:-"${client_api_key,,}"}
    tempfile="${client_id}.${id}.${a}.$(date +%s)"
    es_url=
    log_debug "sending payload to client id [${client_id}]"
  
    document="${miner}.${a}.${id}"
    
    if [ "${init}" == "true" ]; then
      option=write
    fi

    if [ "${id}" ]; then
      if [ "${option}" == "write" ]; then
        echo "${payload}" > /tmp/"${tempfile}"

        case ${miner} in
                      bobcat|helium|longap|nebra|sensecap)
                        index="hnt-${client_id}"
                        ;;
                      wallet.billing)
                        es_url=${wallet_billing_backend_url}
                        ;;
        esac
    
        case ${id} in
                   collector.info)
                     index="hnt-${client_id}"
                     ;;
        esac
    
        index=${index:-"hnt-${client_id}.${global_day}"}
        es_url=${es_url:-"${elasticsearch_url}"}

        es_post=$(curl ${curl_options} -X POST -H "apikey: ${client_api_key}" -H "Content-Type: application/json" "${es_url}/${index}/_doc/${document}" -d @/tmp/"${tempfile}") || log_err "could not post collector data to elasticsearch"

      elif [ "${option}" == "append" ]; then
        index="hnt-${client_id}.${global_day}"
        upd_data=$(jq -r '.data[]' <<< "${payload}")
        upd_payload > /tmp/"${tempfile}"

        es_post=$(curl ${curl_options} -X POST -H "apikey: ${client_api_key}" -H "Content-Type: application/json" "${es_url}/${index}/_doc/${document}/_update" -d @/tmp/"${tempfile}") || log_err "could not append collector data to elasticsearch"
        
        if [ ! "$(jq -r '.result' <<< "${es_post}")" == "updated"  ]; then
          echo "${payload}" > /tmp/"${tempfile}"
          es_post=$(curl ${curl_options} -X POST -H "apikey: ${client_api_key}" -H "Content-Type: application/json" "${es_url}/${index}/_doc/${document}" -d @/tmp/"${tempfile}") || log_err "could not post collector data to elasticsearch after failed append"
        else
          log_info "updated elasticsearch document [${document}]"
        fi
      else
        log_err "invalid option ${option}"
      fi
    else
      log_err "no document name to send payload was specified"
    fi
   
    log_debug "elasticsearch response ${es_post}"
    rm -f /tmp/"${tempfile}"
  fi
}

blockchain_success_payload() {
  jq 'select(.data != null)' <<< "${payload}" 2>/dev/null
}

bobcat_miner_success_payload() {
  jq 'select(.miner != null)' <<< "${payload}" 2>/dev/null
}

bobcat_temp_success_payload() {
  jq 'select(.unit != null)' <<< "${payload}" 2>/dev/null
}

bobcat_status_success_payload() {
  jq 'select(.status != null)' <<< "${payload}" 2>/dev/null
}

longap_success_payload() {
  jq 'select(.[].publicKey != null)' <<< "${payload}" 2>/dev/null
}

nebra_success_payload() {
  jq 'select(.AN != null)' <<< "${payload}" 2>/dev/null
}

sensecap_success_payload() {
  jq 'select(.data.name != null)' <<< "${payload}" 2>/dev/null
}

upd_payload() {
cat <<EOF
{
  "script": {
    "source": "ctx._source.data.add(params.data)",
    "lang": "painless",
    "params": {
      "data":
${upd_data}
    }
  }
}
EOF
}

validate_payload() {
  jq '.data[]' <<< "${payload}" 2>/dev/null
}
